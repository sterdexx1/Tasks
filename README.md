# Тестовое задание
## Описание ТЗ 1 (Практическое задание - StringBuilder)
- Изучите внутреннюю реализацию класса ```StringBuilder``` и напишите свою с добавлением дополнительного метода - ```undo()```

- Прежде чем приступать - прочитайте про паттерн snapshot и примените его в своей реализации

- Примечание: полностью переписывать все методы которые есть в ```StringBuilder``` не нужно, в задании важно именно понимание сути паттерна. В случае, если задание остаётся непонятным, задайте вопрос ментору
## Описание ТЗ 2 (Практическое задание - Collection - фильтрация)
- Напишите метод ```filter```, который принимает на вход массив любого типа, вторым арументом метод должен принимать класс, реализующий интерфейс ```Filter```, в котором один метод - ```T apply(T o)``` (параметризованный)
- Метод должен быть реализован так чтобы возвращать новый массив, к каждому элементу которого была применена функция ```apply```
## Описание ТЗ 3 (Практическое задание - Collection - count of elements)
- Напишите метод, который получает на вход массив элементов и возвращает ```Map```, ключи в котором - элементы, а значения - сколько раз встретился этот элемент
## Описание ТЗ 4 (Практическая задача - Concurrency - блокирующая очередь)
- Предположим, у вас есть пул потоков, и вы хотите реализовать блокирующую очередь для передачи задач между потоками.
- Создайте класс ```BlockingQueue```, который будет обеспечивать безопасное добавление и извлечение элементов между производителями и потребителями в контексте пула потоков.
- Класс ```BlockingQueue``` должен содержать методы ```enqueue()``` для добавления элемента в очередь и ```dequeue()``` для извлечения элемента.
- Если очередь пуста, ```dequeue()``` должен блокировать вызывающий поток до появления нового элемента.
- очередь должна иметь фиксированный размер.
- Используйте механизмы ```wait()``` и ```notify()``` для координации между производителями и потребителями.
- Реализуйте метод ```size()```, который возвращает текущий размер очереди.
# Работа приложения
## Основная логика ТЗ 1 (Практическое задание - StringBuilder)
1. Класс ```MyStringBuilder``` содержит в себе поле класса ```StringBuilder```, что дает возможность полностью реализовать методы класса ```StringBuilder```
2. Класс ```MyStringBuilder``` содержит в себе метод ```createMemory()```, что позволяет сохранить данные в память
3. Класс ```MyStringBuilder``` содержит в себе метод ```undo()```, что позволяет вернуть данные, сохранненые в памяти
## Основная логика ТЗ 2 (Практическое задание - Collection - фильтрация)
1. Интерфейс ```Filter``` содержит в себе один параметризированный метод ```apply(T o)```, возвращаемый тип которого - объект любого типа
2. Класс ```FilterArray``` содержит в себе метод ```filter```, принимающий на вход массив любого типа, вторым арументом метод должен принимает класс, реализующий интерфейс ```Filter```
## Основная логика ТЗ 3 (Практическое задание - Collection - count of elements)
1. Класс ```Main``` содержит в себе статический метод ```returnElementAndCount```, принимающий в качестве параметра массив любого типа и возвращающий ```Map```, ключи в котором - элементы, а значения - сколько раз встретился этот элемент
## Основная логика ТЗ 4 (Практическая задача - Concurrency - блокирующая очередь)
1. Класс ```BlockingQueue``` содержит в себе синхронизированный метод ```enqueue(Object object)```, принимающий в качестве параметра объект, данный метод позволяет добавлять элементы в очередь
2. Класс ```BlockingQueue``` содержит в себе синхронизированный метод ```dequeue()```, возвращающий элемент, данный метод позволяет блокировать вызывающий поток до нового элемента и извлекать нужный нам элемент
3. Класс ```BlockingQueue``` содержит в себе метод ```size()```, возвращающий текущий размер очереди
## Тестирование ТЗ 1 (Практическое задание - StringBuilder)
1. Написан тест ```testSetText()```, который позволяет протестировать присвоение ```StringBuilder``` нашему классу ```MyStringBuilder```
2. Написан тест ```testCreateAndUndo()```, который позволяет протестировать работоспособность методов ```createMemory()``` и ```undo()```
## Тестирование ТЗ 2 (Практическое задание - Collection - фильтрация)
1. Написан тест ```testSizeArray()```, позволяющий протестировать присвоение значений элементов массива
2. Написан тест ```testFilterWhenTheNumbersIsEven()```, который позволяет протестировать работоспособность статического метода ```filter```
## Тестирование ТЗ 3 (Практическое задание - Collection - count of elements)
1. Написан тест ```testCounter()```, который позволяет протестировать работоспособность статического метода ```returnElementAndCount```
## Тестирование ТЗ 4 (Практическая задача - Concurrency - блокирующая очередь)
1. Написан тест ```testSingleThreadEnqueueDequeue()```, позволяющий протестировать работу ```enqueue()``` и ```dequeue()``` методов
2. Написан тест ```testInitMethodSize()```, позволяющий протестировать инициализацию метода ```size()```
3. Написан тест ```testSizeAfterDequeue()```, позволяющий дополнительно протестировать работоспособность ```enqueue()``` и ```dequeue()``` методов
4. Написан тест ```testSizeWhenFull()```, позволяющий протестировать полностью загруженную очередь
