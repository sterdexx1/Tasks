# Тестовое задание
## Описание ТЗ 1 (Практическое задание - StringBuilder)
- Изучите внутреннюю реализацию класса ```StringBuilder``` и напишите свою с добавлением дополнительного метода - ```undo()```
- Прежде чем приступать - прочитайте про паттерн snapshot и примените его в своей реализации
- Примечание: полностью переписывать все методы которые есть в ```StringBuilder``` не нужно, в задании важно именно понимание сути паттерна. В случае, если задание остаётся непонятным, задайте вопрос ментору
## Описание ТЗ 2 (Практическое задание - Collection - фильтрация)
- Напишите метод ```filter```, который принимает на вход массив любого типа, вторым арументом метод должен принимать класс, реализующий интерфейс ```Filter```, в котором один метод - ```T apply(T o)``` (параметризованный)
- Метод должен быть реализован так чтобы возвращать новый массив, к каждому элементу которого была применена функция ```apply```
## Описание ТЗ 3 (Практическое задание - Collection - count of elements)
- Напишите метод, который получает на вход массив элементов и возвращает ```Map```, ключи в котором - элементы, а значения - сколько раз встретился этот элемент
## Описание ТЗ 4 (Практическая задача - Concurrency - блокирующая очередь)
- Предположим, у вас есть пул потоков, и вы хотите реализовать блокирующую очередь для передачи задач между потоками.
- Создайте класс ```BlockingQueue```, который будет обеспечивать безопасное добавление и извлечение элементов между производителями и потребителями в контексте пула потоков.
- Класс ```BlockingQueue``` должен содержать методы ```enqueue()``` для добавления элемента в очередь и ```dequeue()``` для извлечения элемента.
- Если очередь пуста, ```dequeue()``` должен блокировать вызывающий поток до появления нового элемента.
- очередь должна иметь фиксированный размер.
- Используйте механизмы ```wait()``` и ```notify()``` для координации между производителями и потребителями.
- Реализуйте метод ```size()```, который возвращает текущий размер очереди.
## Описание ТЗ 5 (Практическое задание - Concurrency - синхронизаторы)
- Синхронизация потоков с использованием ```CyclicBarrier``` и ```ExecutorService```
- В этой задаче мы будем использовать ```CyclicBarrier``` и ```ExecutorService``` для синхронизации нескольких потоков, выполняющих сложную задачу, и затем ожидающих, пока все потоки завершат выполнение, чтобы объединить результаты.
- Создайте класс ```ComplexTask```, представляющий сложную задачу, которую несколько потоков будут выполнять. В каждой задаче реализуйте метод ```execute()```, который выполняет часть сложной задачи.
- Создайте класс ```ComplexTaskExecutor```, в котором будет использоваться ```CyclicBarrier``` и ```ExecutorService``` для синхронизации выполнения задач. Реализуйте метод ```executeTasks(int numberOfTasks)```, который создает пул потоков и назначает каждому потоку экземпляр сложной задачи для выполнения. Затем используйте ```CyclicBarrier``` для ожидания завершения всех потоков и объединения результатов их работы. В методе ```main``` создайте экземпляр ```ComplexTaskExecutor``` и вызовите метод ```executeTasks``` с несколькими задачами для выполнения.
## Описание ТЗ 6 (Практическая задача - Concurrency - многопоточный банковский счет)
- В виртуальном банке ```"ConcurrentBank"``` решено внедрить многопоточность для обработки операций по счетам клиентов. Система должна поддерживать возможность одновременного пополнения (deposit), снятия (withdraw), а также переводов (transfer) между счетами. Каждый счет имеет свой уникальный номер.
- Реализуйте класс ```BankAccount``` с методами ```deposit```, ```withdraw``` и ```getBalance```, поддерживающими многопоточное взаимодействие.
- Реализуйте класс ```ConcurrentBank``` для управления счетами и выполнения переводов между ними. Класс должен предоставлять методы ```createAccount``` для создания нового счета и ```transfer``` для выполнения переводов между счетами.
- Переводы между счетами должны быть атомарными, чтобы избежать ситуаций, когда одна часть транзакции выполняется успешно, а другая нет.
- Реализуйте метод ```getTotalBalance```, который возвращает общий баланс всех счетов в банке.
## Описание ТЗ 7 (Практическое задание - Stream API - генерация чисел)
- Предположим, у нас есть список заказов, и каждый заказ представляет собой продукт и его стоимость. Задача состоит в использовании Stream API и коллекторов для решения следующих задач:
1. Создайте список заказов с разными продуктами и их стоимостями.
2. Группируйте заказы по продуктам.
3. Для каждого продукта найдите общую стоимость всех заказов.
4. Отсортируйте продукты по убыванию общей стоимости.
5. Выберите три самых дорогих продукта.
6. Выведите результат: список трех самых дорогих продуктов и их общая стоимость.
## Описание ТЗ 8 (Практическое задачние - Stream API - агрегация и объединение результатов)
- Создайте коллекцию студентов, где каждый студент содержит информацию о предметах, которые он изучает, и его оценках по этим предметам.
- Используйте ```Parallel Stream``` для обработки данных и создания ```Map```, где ключ - предмет, а значение - средняя оценка по всем студентам.
- Выведите результат: общую ```Map``` с средними оценками по всем предметам.
## Описание ТЗ 9 (Практическое задание - Stream API - ForkJoinPool: Рекурсивное вычисление факториала)
- Рассмотрим задачу вычисления факториала числа с использованием ForkJoinPool. Факториал числа n обозначается как n! и вычисляется как произведение всех положительных целых чисел от 1 до n.
- Реализуйте класс ```FactorialTask```, который расширяет RecursiveTask. Этот класс будет выполнять рекурсивное вычисление факториала числа.
- В конструкторе ```FactorialTask``` передайте число n, факториал которого нужно вычислить.
- В методе ```compute()``` разбейте задачу на подзадачи и используйте ```fork()``` для их асинхронного выполнения.
- Используйте ```join()``` для получения результатов подзадач и комбинирования их для получения общего результата.
- В основном методе создайте экземпляр ```FactorialTask``` с числом, для которого нужно вычислить факториал, и запустите его в ```ForkJoinPool```.
- Выведите результат вычисления факториала.
# Работа приложения
## Основная логика ТЗ 1 (Практическое задание - StringBuilder)
1. Класс ```MyStringBuilder``` содержит в себе поле класса ```StringBuilder```, что дает возможность полностью реализовать методы класса ```StringBuilder```
2. Класс ```MyStringBuilder``` содержит в себе метод ```createMemory()```, что позволяет сохранить данные в память
3. Класс ```MyStringBuilder``` содержит в себе метод ```undo()```, что позволяет вернуть данные, сохранненые в памяти
## Основная логика ТЗ 2 (Практическое задание - Collection - фильтрация)
1. Интерфейс ```Filter``` содержит в себе один параметризированный метод ```apply(T o)```, возвращаемый тип которого - объект любого типа
2. Класс ```FilterArray``` содержит в себе метод ```filter```, принимающий на вход массив любого типа, вторым арументом метод должен принимает класс, реализующий интерфейс ```Filter```
## Основная логика ТЗ 3 (Практическое задание - Collection - count of elements)
1. Класс ```Main``` содержит в себе статический метод ```returnElementAndCount```, принимающий в качестве параметра массив любого типа и возвращающий ```Map```, ключи в котором - элементы, а значения - сколько раз встретился этот элемент
## Основная логика ТЗ 4 (Практическая задача - Concurrency - блокирующая очередь)
1. Класс ```BlockingQueue``` содержит в себе синхронизированный метод ```enqueue(Object object)```, принимающий в качестве параметра объект, данный метод позволяет добавлять элементы в очередь
2. Класс ```BlockingQueue``` содержит в себе синхронизированный метод ```dequeue()```, возвращающий элемент, данный метод позволяет блокировать вызывающий поток до нового элемента и извлекать нужный нам элемент
3. Класс ```BlockingQueue``` содержит в себе метод ```size()```, возвращающий текущий размер очереди
## Основная логика ТЗ 5 (Практическое задание - Concurrency - синхронизаторы)
1. Класс ```ComplexTask``` имплементирует интерфейс ```Runnable```, что позволяет создавать потоки
2. Класс ```ComplexTask``` содержит метод ```execute()```, реализирующий симуляцию выполнения задачи и переопределенный метод ```run()```, определяющий логику потока
3. Класс ```ComplexTask``` имеет конструктор, принимающий в качестве параметра задачу ```task``` типа ```int```
4. Класс ```ComplexTaskExecutor``` в качестве синхронизатора включает в себя ```CyclicBarrier```
5. Класс ```ComplexTaskExecutor``` имеет конструктор, принимающий в качестве параметра количество задач в пуле ```numberOfTasks``` типа ```int```
6. Класс ```ComplexTaskExecutor``` содержит метод ```executeTasks(int numberOfTasks)```, который отвечает за создание пула определенной величины ```(numberOfTasks)``` и передачи задачи в поток
## Основная логика ТЗ 6 (Практическая задача - Concurrency - многопоточный банковский счет)
1. Класс ```BankAccount``` содержит в себе поля и методы, определяющие логику операций над счетом и данные счета (количество средств и номер счета)
2. Класс ```ConcurrentBank``` содержит в себе поля и методы, определяющие логику действий и информацию о существующих счетах и метод для создания новых
## Основная логика ТЗ 7 (Практическое задание - Stream API - генерация чисел)
1. Класс ```StreamCollectorsExample``` содержит в себе вложенный класс ```Order``` и в методе ```main``` создает массив объектов данного класса, далее проводит над массивом определенные операции в условиях ТЗ
## Основная логика ТЗ 8 (Практическое задачние - Stream API - агрегация и объединение результатов)
1. Класс ```ParallelStreamCollectMapAdvancedExample``` содержит в себе вложенный класс ```Student``` и в методе ```main``` создает массив объектов данного класса, далее проводит над массивом определенные операции в условиях ТЗ
## Основная логика ТЗ 9 (Практическое задание - Stream API - ForkJoinPool: Рекурсивное вычисление факториала)
1. Класс ```FactorialTask``` наследует класс ```RecursiveTask<Integer>``` и содержит в себе переопределенный метод ```compute```, который содержит в себе логику распределения задач
# Тестирование
## Тестирование ТЗ 1 (Практическое задание - StringBuilder)
1. Написан тест ```testSetText()```, который позволяет протестировать присвоение ```StringBuilder``` нашему классу ```MyStringBuilder```
2. Написан тест ```testCreateAndUndo()```, который позволяет протестировать работоспособность методов ```createMemory()``` и ```undo()```
## Тестирование ТЗ 2 (Практическое задание - Collection - фильтрация)
1. Написан тест ```testSizeArray()```, позволяющий протестировать присвоение значений элементов массива
2. Написан тест ```testFilterWhenTheNumbersIsEven()```, который позволяет протестировать работоспособность статического метода ```filter```
## Тестирование ТЗ 3 (Практическое задание - Collection - count of elements)
1. Написан тест ```testCounter()```, который позволяет протестировать работоспособность статического метода ```returnElementAndCount```
## Тестирование ТЗ 4 (Практическая задача - Concurrency - блокирующая очередь)
1. Написан тест ```testSingleThreadEnqueueDequeue()```, позволяющий протестировать работу ```enqueue()``` и ```dequeue()``` методов
2. Написан тест ```testInitMethodSize()```, позволяющий протестировать инициализацию метода ```size()```
3. Написан тест ```testSizeAfterDequeue()```, позволяющий дополнительно протестировать работоспособность ```enqueue()``` и ```dequeue()``` методов
4. Написан тест ```testSizeWhenFull()```, позволяющий протестировать полностью загруженную очередь
## Тестирование ТЗ 5 (Практическое задание - Concurrency - синхронизаторы)
1. Код для тестирования
   ```public class TestComplexTaskExecutor {

    public static void main(String[] args) {
        ComplexTaskExecutor taskExecutor = new ComplexTaskExecutor(5); // Количество задач для выполнения

        Runnable testRunnable = () -> {
            System.out.println(Thread.currentThread().getName() + " started the test.");

            // Выполнение задач
            taskExecutor.executeTasks(5);

            System.out.println(Thread.currentThread().getName() + " completed the test.");
        };

        Thread thread1 = new Thread(testRunnable, "TestThread-1");
        Thread thread2 = new Thread(testRunnable, "TestThread-2");

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
## Тестирование ТЗ 6 (Практическая задача - Concurrency - многопоточный банковский счет)
1. Код для тестирования
   ```public class ConcurrentBankExample {
    public static void main(String[] args) {
        ConcurrentBank bank = new ConcurrentBank();

        // Создание счетов
        BankAccount account1 = bank.createAccount(1000);
        BankAccount account2 = bank.createAccount(500);

        // Перевод между счетами
        Thread transferThread1 = new Thread(() -> bank.transfer(account1, account2, 200));
        Thread transferThread2 = new Thread(() -> bank.transfer(account2, account1, 100));

        transferThread1.start();
        transferThread2.start();

        try {
            transferThread1.join();
            transferThread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Вывод общего баланса
        System.out.println("Total balance: " + bank.getTotalBalance());
      }
  ## Тестирование ТЗ 7 (Практическое задание - Stream API - генерация чисел)
  1. Код для тестирования
     ``` class Order {
    private String product;
    private double cost;
    public Order(String product, double cost) {
        this.product = product;
        this.cost = cost;
    }

    public String getProduct() {
        return product;
    }

    public double getCost() {
        return cost;
    } public class StreamCollectorsExample {
    public static void main(String[] args) {
        List<Order> orders = List.of(
                new Order("Laptop", 1200.0),
                new Order("Smartphone", 800.0),
                new Order("Laptop", 1500.0),
                new Order("Tablet", 500.0),
                new Order("Smartphone", 900.0)
        );
## Тестирование ТЗ 8 (Практическое задачние - Stream API - агрегация и объединение результатов)
1. Код для тестирования
```   class Student {
    private String name;
    private Map<String, Integer> grades;

    public Student(String name, Map<String, Integer> grades) {
        this.name = name;
        this.grades = grades;
    }

    public Map<String, Integer> getGrades() {
        return grades;
    }
}

public class ParallelStreamCollectMapAdvancedExample {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
                new Student("Student1", Map.of("Math", 90, "Physics", 85)),
                new Student("Student2", Map.of("Math", 95, "Physics", 88)),
                new Student("Student3", Map.of("Math", 88, "Chemistry", 92)),
                new Student("Student4", Map.of("Physics", 78, "Chemistry", 85))
        );
}
```
## Тестирование ТЗ 9 (Практическое задание - Stream API - ForkJoinPool: Рекурсивное вычисление факториала)
1. Код для тестирования
``` public class ForkJoinPoolExample {
    public static void main(String[] args) {
        int n = 10; // Вычисление факториала для числа 10

        ForkJoinPool forkJoinPool = new ForkJoinPool();
        FactorialTask factorialTask = new FactorialTask(n);

        long result = forkJoinPool.invoke(factorialTask);

        System.out.println("Факториал " + n + "! = " + result);
    }
}
```   

